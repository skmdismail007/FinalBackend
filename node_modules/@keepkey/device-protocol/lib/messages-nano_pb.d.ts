// package: 
// file: messages-nano.proto

import * as jspb from "google-protobuf";

export class NanoGetAddress extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasCoinName(): boolean;
  clearCoinName(): void;
  getCoinName(): string | undefined;
  setCoinName(value: string): void;

  hasShowDisplay(): boolean;
  clearShowDisplay(): void;
  getShowDisplay(): boolean | undefined;
  setShowDisplay(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NanoGetAddress.AsObject;
  static toObject(includeInstance: boolean, msg: NanoGetAddress): NanoGetAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NanoGetAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NanoGetAddress;
  static deserializeBinaryFromReader(message: NanoGetAddress, reader: jspb.BinaryReader): NanoGetAddress;
}

export namespace NanoGetAddress {
  export type AsObject = {
    addressNList: Array<number>,
    coinName?: string,
    showDisplay?: boolean,
  }
}

export class NanoAddress extends jspb.Message {
  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): string | undefined;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NanoAddress.AsObject;
  static toObject(includeInstance: boolean, msg: NanoAddress): NanoAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NanoAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NanoAddress;
  static deserializeBinaryFromReader(message: NanoAddress, reader: jspb.BinaryReader): NanoAddress;
}

export namespace NanoAddress {
  export type AsObject = {
    address?: string,
  }
}

export class NanoSignTx extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasCoinName(): boolean;
  clearCoinName(): void;
  getCoinName(): string | undefined;
  setCoinName(value: string): void;

  hasParentBlock(): boolean;
  clearParentBlock(): void;
  getParentBlock(): NanoSignTx.ParentBlock | undefined;
  setParentBlock(value?: NanoSignTx.ParentBlock): void;

  hasLinkHash(): boolean;
  clearLinkHash(): void;
  getLinkHash(): Uint8Array | string;
  getLinkHash_asU8(): Uint8Array;
  getLinkHash_asB64(): string;
  setLinkHash(value: Uint8Array | string): void;

  hasLinkRecipient(): boolean;
  clearLinkRecipient(): void;
  getLinkRecipient(): string | undefined;
  setLinkRecipient(value: string): void;

  clearLinkRecipientNList(): void;
  getLinkRecipientNList(): Array<number>;
  setLinkRecipientNList(value: Array<number>): void;
  addLinkRecipientN(value: number, index?: number): number;

  hasRepresentative(): boolean;
  clearRepresentative(): void;
  getRepresentative(): string | undefined;
  setRepresentative(value: string): void;

  hasBalance(): boolean;
  clearBalance(): void;
  getBalance(): Uint8Array | string;
  getBalance_asU8(): Uint8Array;
  getBalance_asB64(): string;
  setBalance(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NanoSignTx.AsObject;
  static toObject(includeInstance: boolean, msg: NanoSignTx): NanoSignTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NanoSignTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NanoSignTx;
  static deserializeBinaryFromReader(message: NanoSignTx, reader: jspb.BinaryReader): NanoSignTx;
}

export namespace NanoSignTx {
  export type AsObject = {
    addressNList: Array<number>,
    coinName?: string,
    parentBlock?: NanoSignTx.ParentBlock.AsObject,
    linkHash: Uint8Array | string,
    linkRecipient?: string,
    linkRecipientNList: Array<number>,
    representative?: string,
    balance: Uint8Array | string,
  }

  export class ParentBlock extends jspb.Message {
    hasParentHash(): boolean;
    clearParentHash(): void;
    getParentHash(): Uint8Array | string;
    getParentHash_asU8(): Uint8Array;
    getParentHash_asB64(): string;
    setParentHash(value: Uint8Array | string): void;

    hasLink(): boolean;
    clearLink(): void;
    getLink(): Uint8Array | string;
    getLink_asU8(): Uint8Array;
    getLink_asB64(): string;
    setLink(value: Uint8Array | string): void;

    hasRepresentative(): boolean;
    clearRepresentative(): void;
    getRepresentative(): string | undefined;
    setRepresentative(value: string): void;

    hasBalance(): boolean;
    clearBalance(): void;
    getBalance(): Uint8Array | string;
    getBalance_asU8(): Uint8Array;
    getBalance_asB64(): string;
    setBalance(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ParentBlock.AsObject;
    static toObject(includeInstance: boolean, msg: ParentBlock): ParentBlock.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ParentBlock, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ParentBlock;
    static deserializeBinaryFromReader(message: ParentBlock, reader: jspb.BinaryReader): ParentBlock;
  }

  export namespace ParentBlock {
    export type AsObject = {
      parentHash: Uint8Array | string,
      link: Uint8Array | string,
      representative?: string,
      balance: Uint8Array | string,
    }
  }
}

export class NanoSignedTx extends jspb.Message {
  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  hasBlockHash(): boolean;
  clearBlockHash(): void;
  getBlockHash(): Uint8Array | string;
  getBlockHash_asU8(): Uint8Array;
  getBlockHash_asB64(): string;
  setBlockHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NanoSignedTx.AsObject;
  static toObject(includeInstance: boolean, msg: NanoSignedTx): NanoSignedTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NanoSignedTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NanoSignedTx;
  static deserializeBinaryFromReader(message: NanoSignedTx, reader: jspb.BinaryReader): NanoSignedTx;
}

export namespace NanoSignedTx {
  export type AsObject = {
    signature: Uint8Array | string,
    blockHash: Uint8Array | string,
  }
}

