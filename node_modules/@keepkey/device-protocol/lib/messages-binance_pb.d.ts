// package: 
// file: messages-binance.proto

import * as jspb from "google-protobuf";
import * as types_pb from "./types_pb";

export class BinanceGetAddress extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasShowDisplay(): boolean;
  clearShowDisplay(): void;
  getShowDisplay(): boolean | undefined;
  setShowDisplay(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceGetAddress.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceGetAddress): BinanceGetAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceGetAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceGetAddress;
  static deserializeBinaryFromReader(message: BinanceGetAddress, reader: jspb.BinaryReader): BinanceGetAddress;
}

export namespace BinanceGetAddress {
  export type AsObject = {
    addressNList: Array<number>,
    showDisplay?: boolean,
  }
}

export class BinanceAddress extends jspb.Message {
  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): string | undefined;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceAddress.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceAddress): BinanceAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceAddress;
  static deserializeBinaryFromReader(message: BinanceAddress, reader: jspb.BinaryReader): BinanceAddress;
}

export namespace BinanceAddress {
  export type AsObject = {
    address?: string,
  }
}

export class BinanceGetPublicKey extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasShowDisplay(): boolean;
  clearShowDisplay(): void;
  getShowDisplay(): boolean | undefined;
  setShowDisplay(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceGetPublicKey.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceGetPublicKey): BinanceGetPublicKey.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceGetPublicKey, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceGetPublicKey;
  static deserializeBinaryFromReader(message: BinanceGetPublicKey, reader: jspb.BinaryReader): BinanceGetPublicKey;
}

export namespace BinanceGetPublicKey {
  export type AsObject = {
    addressNList: Array<number>,
    showDisplay?: boolean,
  }
}

export class BinancePublicKey extends jspb.Message {
  hasPublicKey(): boolean;
  clearPublicKey(): void;
  getPublicKey(): Uint8Array | string;
  getPublicKey_asU8(): Uint8Array;
  getPublicKey_asB64(): string;
  setPublicKey(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinancePublicKey.AsObject;
  static toObject(includeInstance: boolean, msg: BinancePublicKey): BinancePublicKey.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinancePublicKey, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinancePublicKey;
  static deserializeBinaryFromReader(message: BinancePublicKey, reader: jspb.BinaryReader): BinancePublicKey;
}

export namespace BinancePublicKey {
  export type AsObject = {
    publicKey: Uint8Array | string,
  }
}

export class BinanceSignTx extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasMsgCount(): boolean;
  clearMsgCount(): void;
  getMsgCount(): number | undefined;
  setMsgCount(value: number): void;

  hasAccountNumber(): boolean;
  clearAccountNumber(): void;
  getAccountNumber(): string | undefined;
  setAccountNumber(value: string): void;

  hasChainId(): boolean;
  clearChainId(): void;
  getChainId(): string | undefined;
  setChainId(value: string): void;

  hasMemo(): boolean;
  clearMemo(): void;
  getMemo(): string | undefined;
  setMemo(value: string): void;

  hasSequence(): boolean;
  clearSequence(): void;
  getSequence(): string | undefined;
  setSequence(value: string): void;

  hasSource(): boolean;
  clearSource(): void;
  getSource(): string | undefined;
  setSource(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceSignTx.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceSignTx): BinanceSignTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceSignTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceSignTx;
  static deserializeBinaryFromReader(message: BinanceSignTx, reader: jspb.BinaryReader): BinanceSignTx;
}

export namespace BinanceSignTx {
  export type AsObject = {
    addressNList: Array<number>,
    msgCount?: number,
    accountNumber?: string,
    chainId?: string,
    memo?: string,
    sequence?: string,
    source?: string,
  }
}

export class BinanceTxRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceTxRequest.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceTxRequest): BinanceTxRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceTxRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceTxRequest;
  static deserializeBinaryFromReader(message: BinanceTxRequest, reader: jspb.BinaryReader): BinanceTxRequest;
}

export namespace BinanceTxRequest {
  export type AsObject = {
  }
}

export class BinanceTransferMsg extends jspb.Message {
  clearInputsList(): void;
  getInputsList(): Array<BinanceTransferMsg.BinanceInputOutput>;
  setInputsList(value: Array<BinanceTransferMsg.BinanceInputOutput>): void;
  addInputs(value?: BinanceTransferMsg.BinanceInputOutput, index?: number): BinanceTransferMsg.BinanceInputOutput;

  clearOutputsList(): void;
  getOutputsList(): Array<BinanceTransferMsg.BinanceInputOutput>;
  setOutputsList(value: Array<BinanceTransferMsg.BinanceInputOutput>): void;
  addOutputs(value?: BinanceTransferMsg.BinanceInputOutput, index?: number): BinanceTransferMsg.BinanceInputOutput;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceTransferMsg.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceTransferMsg): BinanceTransferMsg.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceTransferMsg, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceTransferMsg;
  static deserializeBinaryFromReader(message: BinanceTransferMsg, reader: jspb.BinaryReader): BinanceTransferMsg;
}

export namespace BinanceTransferMsg {
  export type AsObject = {
    inputsList: Array<BinanceTransferMsg.BinanceInputOutput.AsObject>,
    outputsList: Array<BinanceTransferMsg.BinanceInputOutput.AsObject>,
  }

  export class BinanceInputOutput extends jspb.Message {
    hasAddress(): boolean;
    clearAddress(): void;
    getAddress(): string | undefined;
    setAddress(value: string): void;

    clearCoinsList(): void;
    getCoinsList(): Array<BinanceTransferMsg.BinanceCoin>;
    setCoinsList(value: Array<BinanceTransferMsg.BinanceCoin>): void;
    addCoins(value?: BinanceTransferMsg.BinanceCoin, index?: number): BinanceTransferMsg.BinanceCoin;

    hasAddressType(): boolean;
    clearAddressType(): void;
    getAddressType(): types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap] | undefined;
    setAddressType(value: types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap]): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): BinanceInputOutput.AsObject;
    static toObject(includeInstance: boolean, msg: BinanceInputOutput): BinanceInputOutput.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: BinanceInputOutput, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): BinanceInputOutput;
    static deserializeBinaryFromReader(message: BinanceInputOutput, reader: jspb.BinaryReader): BinanceInputOutput;
  }

  export namespace BinanceInputOutput {
    export type AsObject = {
      address?: string,
      coinsList: Array<BinanceTransferMsg.BinanceCoin.AsObject>,
      addressType?: types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap],
    }
  }

  export class BinanceCoin extends jspb.Message {
    hasAmount(): boolean;
    clearAmount(): void;
    getAmount(): string | undefined;
    setAmount(value: string): void;

    hasDenom(): boolean;
    clearDenom(): void;
    getDenom(): string | undefined;
    setDenom(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): BinanceCoin.AsObject;
    static toObject(includeInstance: boolean, msg: BinanceCoin): BinanceCoin.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: BinanceCoin, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): BinanceCoin;
    static deserializeBinaryFromReader(message: BinanceCoin, reader: jspb.BinaryReader): BinanceCoin;
  }

  export namespace BinanceCoin {
    export type AsObject = {
      amount?: string,
      denom?: string,
    }
  }
}

export class BinanceOrderMsg extends jspb.Message {
  hasId(): boolean;
  clearId(): void;
  getId(): string | undefined;
  setId(value: string): void;

  hasOrdertype(): boolean;
  clearOrdertype(): void;
  getOrdertype(): BinanceOrderMsg.BinanceOrderTypeMap[keyof BinanceOrderMsg.BinanceOrderTypeMap] | undefined;
  setOrdertype(value: BinanceOrderMsg.BinanceOrderTypeMap[keyof BinanceOrderMsg.BinanceOrderTypeMap]): void;

  hasPrice(): boolean;
  clearPrice(): void;
  getPrice(): string | undefined;
  setPrice(value: string): void;

  hasQuantity(): boolean;
  clearQuantity(): void;
  getQuantity(): string | undefined;
  setQuantity(value: string): void;

  hasSender(): boolean;
  clearSender(): void;
  getSender(): string | undefined;
  setSender(value: string): void;

  hasSide(): boolean;
  clearSide(): void;
  getSide(): BinanceOrderMsg.BinanceOrderSideMap[keyof BinanceOrderMsg.BinanceOrderSideMap] | undefined;
  setSide(value: BinanceOrderMsg.BinanceOrderSideMap[keyof BinanceOrderMsg.BinanceOrderSideMap]): void;

  hasSymbol(): boolean;
  clearSymbol(): void;
  getSymbol(): string | undefined;
  setSymbol(value: string): void;

  hasTimeinforce(): boolean;
  clearTimeinforce(): void;
  getTimeinforce(): BinanceOrderMsg.BinanceTimeInForceMap[keyof BinanceOrderMsg.BinanceTimeInForceMap] | undefined;
  setTimeinforce(value: BinanceOrderMsg.BinanceTimeInForceMap[keyof BinanceOrderMsg.BinanceTimeInForceMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceOrderMsg.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceOrderMsg): BinanceOrderMsg.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceOrderMsg, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceOrderMsg;
  static deserializeBinaryFromReader(message: BinanceOrderMsg, reader: jspb.BinaryReader): BinanceOrderMsg;
}

export namespace BinanceOrderMsg {
  export type AsObject = {
    id?: string,
    ordertype?: BinanceOrderMsg.BinanceOrderTypeMap[keyof BinanceOrderMsg.BinanceOrderTypeMap],
    price?: string,
    quantity?: string,
    sender?: string,
    side?: BinanceOrderMsg.BinanceOrderSideMap[keyof BinanceOrderMsg.BinanceOrderSideMap],
    symbol?: string,
    timeinforce?: BinanceOrderMsg.BinanceTimeInForceMap[keyof BinanceOrderMsg.BinanceTimeInForceMap],
  }

  export interface BinanceOrderTypeMap {
    OT_UNKNOWN: 0;
    MARKET: 1;
    LIMIT: 2;
    OT_RESERVED: 3;
  }

  export const BinanceOrderType: BinanceOrderTypeMap;

  export interface BinanceOrderSideMap {
    SIDE_UNKNOWN: 0;
    BUY: 1;
    SELL: 2;
  }

  export const BinanceOrderSide: BinanceOrderSideMap;

  export interface BinanceTimeInForceMap {
    TIF_UNKNOWN: 0;
    GTE: 1;
    TIF_RESERVED: 2;
    IOC: 3;
  }

  export const BinanceTimeInForce: BinanceTimeInForceMap;
}

export class BinanceCancelMsg extends jspb.Message {
  hasRefid(): boolean;
  clearRefid(): void;
  getRefid(): string | undefined;
  setRefid(value: string): void;

  hasSender(): boolean;
  clearSender(): void;
  getSender(): string | undefined;
  setSender(value: string): void;

  hasSymbol(): boolean;
  clearSymbol(): void;
  getSymbol(): string | undefined;
  setSymbol(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceCancelMsg.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceCancelMsg): BinanceCancelMsg.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceCancelMsg, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceCancelMsg;
  static deserializeBinaryFromReader(message: BinanceCancelMsg, reader: jspb.BinaryReader): BinanceCancelMsg;
}

export namespace BinanceCancelMsg {
  export type AsObject = {
    refid?: string,
    sender?: string,
    symbol?: string,
  }
}

export class BinanceSignedTx extends jspb.Message {
  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  hasPublicKey(): boolean;
  clearPublicKey(): void;
  getPublicKey(): Uint8Array | string;
  getPublicKey_asU8(): Uint8Array;
  getPublicKey_asB64(): string;
  setPublicKey(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinanceSignedTx.AsObject;
  static toObject(includeInstance: boolean, msg: BinanceSignedTx): BinanceSignedTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinanceSignedTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinanceSignedTx;
  static deserializeBinaryFromReader(message: BinanceSignedTx, reader: jspb.BinaryReader): BinanceSignedTx;
}

export namespace BinanceSignedTx {
  export type AsObject = {
    signature: Uint8Array | string,
    publicKey: Uint8Array | string,
  }
}

