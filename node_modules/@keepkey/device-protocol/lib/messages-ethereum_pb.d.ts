// package: 
// file: messages-ethereum.proto

import * as jspb from "google-protobuf";
import * as types_pb from "./types_pb";

export class EthereumGetAddress extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasShowDisplay(): boolean;
  clearShowDisplay(): void;
  getShowDisplay(): boolean | undefined;
  setShowDisplay(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumGetAddress.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumGetAddress): EthereumGetAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumGetAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumGetAddress;
  static deserializeBinaryFromReader(message: EthereumGetAddress, reader: jspb.BinaryReader): EthereumGetAddress;
}

export namespace EthereumGetAddress {
  export type AsObject = {
    addressNList: Array<number>,
    showDisplay?: boolean,
  }
}

export class EthereumAddress extends jspb.Message {
  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): Uint8Array | string;
  getAddress_asU8(): Uint8Array;
  getAddress_asB64(): string;
  setAddress(value: Uint8Array | string): void;

  hasAddressStr(): boolean;
  clearAddressStr(): void;
  getAddressStr(): string | undefined;
  setAddressStr(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumAddress.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumAddress): EthereumAddress.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumAddress, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumAddress;
  static deserializeBinaryFromReader(message: EthereumAddress, reader: jspb.BinaryReader): EthereumAddress;
}

export namespace EthereumAddress {
  export type AsObject = {
    address: Uint8Array | string,
    addressStr?: string,
  }
}

export class EthereumSignTx extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasNonce(): boolean;
  clearNonce(): void;
  getNonce(): Uint8Array | string;
  getNonce_asU8(): Uint8Array;
  getNonce_asB64(): string;
  setNonce(value: Uint8Array | string): void;

  hasGasPrice(): boolean;
  clearGasPrice(): void;
  getGasPrice(): Uint8Array | string;
  getGasPrice_asU8(): Uint8Array;
  getGasPrice_asB64(): string;
  setGasPrice(value: Uint8Array | string): void;

  hasGasLimit(): boolean;
  clearGasLimit(): void;
  getGasLimit(): Uint8Array | string;
  getGasLimit_asU8(): Uint8Array;
  getGasLimit_asB64(): string;
  setGasLimit(value: Uint8Array | string): void;

  hasTo(): boolean;
  clearTo(): void;
  getTo(): Uint8Array | string;
  getTo_asU8(): Uint8Array;
  getTo_asB64(): string;
  setTo(value: Uint8Array | string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): Uint8Array | string;
  getValue_asU8(): Uint8Array;
  getValue_asB64(): string;
  setValue(value: Uint8Array | string): void;

  hasDataInitialChunk(): boolean;
  clearDataInitialChunk(): void;
  getDataInitialChunk(): Uint8Array | string;
  getDataInitialChunk_asU8(): Uint8Array;
  getDataInitialChunk_asB64(): string;
  setDataInitialChunk(value: Uint8Array | string): void;

  hasDataLength(): boolean;
  clearDataLength(): void;
  getDataLength(): number | undefined;
  setDataLength(value: number): void;

  clearToAddressNList(): void;
  getToAddressNList(): Array<number>;
  setToAddressNList(value: Array<number>): void;
  addToAddressN(value: number, index?: number): number;

  hasAddressType(): boolean;
  clearAddressType(): void;
  getAddressType(): types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap] | undefined;
  setAddressType(value: types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap]): void;

  hasChainId(): boolean;
  clearChainId(): void;
  getChainId(): number | undefined;
  setChainId(value: number): void;

  hasMaxFeePerGas(): boolean;
  clearMaxFeePerGas(): void;
  getMaxFeePerGas(): Uint8Array | string;
  getMaxFeePerGas_asU8(): Uint8Array;
  getMaxFeePerGas_asB64(): string;
  setMaxFeePerGas(value: Uint8Array | string): void;

  hasMaxPriorityFeePerGas(): boolean;
  clearMaxPriorityFeePerGas(): void;
  getMaxPriorityFeePerGas(): Uint8Array | string;
  getMaxPriorityFeePerGas_asU8(): Uint8Array;
  getMaxPriorityFeePerGas_asB64(): string;
  setMaxPriorityFeePerGas(value: Uint8Array | string): void;

  hasTokenValue(): boolean;
  clearTokenValue(): void;
  getTokenValue(): Uint8Array | string;
  getTokenValue_asU8(): Uint8Array;
  getTokenValue_asB64(): string;
  setTokenValue(value: Uint8Array | string): void;

  hasTokenTo(): boolean;
  clearTokenTo(): void;
  getTokenTo(): Uint8Array | string;
  getTokenTo_asU8(): Uint8Array;
  getTokenTo_asB64(): string;
  setTokenTo(value: Uint8Array | string): void;

  hasTokenShortcut(): boolean;
  clearTokenShortcut(): void;
  getTokenShortcut(): string | undefined;
  setTokenShortcut(value: string): void;

  hasTxType(): boolean;
  clearTxType(): void;
  getTxType(): number | undefined;
  setTxType(value: number): void;

  hasType(): boolean;
  clearType(): void;
  getType(): number | undefined;
  setType(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumSignTx.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumSignTx): EthereumSignTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumSignTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumSignTx;
  static deserializeBinaryFromReader(message: EthereumSignTx, reader: jspb.BinaryReader): EthereumSignTx;
}

export namespace EthereumSignTx {
  export type AsObject = {
    addressNList: Array<number>,
    nonce: Uint8Array | string,
    gasPrice: Uint8Array | string,
    gasLimit: Uint8Array | string,
    to: Uint8Array | string,
    value: Uint8Array | string,
    dataInitialChunk: Uint8Array | string,
    dataLength?: number,
    toAddressNList: Array<number>,
    addressType?: types_pb.OutputAddressTypeMap[keyof types_pb.OutputAddressTypeMap],
    chainId?: number,
    maxFeePerGas: Uint8Array | string,
    maxPriorityFeePerGas: Uint8Array | string,
    tokenValue: Uint8Array | string,
    tokenTo: Uint8Array | string,
    tokenShortcut?: string,
    txType?: number,
    type?: number,
  }
}

export class EthereumTxRequest extends jspb.Message {
  hasDataLength(): boolean;
  clearDataLength(): void;
  getDataLength(): number | undefined;
  setDataLength(value: number): void;

  hasSignatureV(): boolean;
  clearSignatureV(): void;
  getSignatureV(): number | undefined;
  setSignatureV(value: number): void;

  hasSignatureR(): boolean;
  clearSignatureR(): void;
  getSignatureR(): Uint8Array | string;
  getSignatureR_asU8(): Uint8Array;
  getSignatureR_asB64(): string;
  setSignatureR(value: Uint8Array | string): void;

  hasSignatureS(): boolean;
  clearSignatureS(): void;
  getSignatureS(): Uint8Array | string;
  getSignatureS_asU8(): Uint8Array;
  getSignatureS_asB64(): string;
  setSignatureS(value: Uint8Array | string): void;

  hasHash(): boolean;
  clearHash(): void;
  getHash(): Uint8Array | string;
  getHash_asU8(): Uint8Array;
  getHash_asB64(): string;
  setHash(value: Uint8Array | string): void;

  hasSignatureDer(): boolean;
  clearSignatureDer(): void;
  getSignatureDer(): Uint8Array | string;
  getSignatureDer_asU8(): Uint8Array;
  getSignatureDer_asB64(): string;
  setSignatureDer(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumTxRequest.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumTxRequest): EthereumTxRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumTxRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumTxRequest;
  static deserializeBinaryFromReader(message: EthereumTxRequest, reader: jspb.BinaryReader): EthereumTxRequest;
}

export namespace EthereumTxRequest {
  export type AsObject = {
    dataLength?: number,
    signatureV?: number,
    signatureR: Uint8Array | string,
    signatureS: Uint8Array | string,
    hash: Uint8Array | string,
    signatureDer: Uint8Array | string,
  }
}

export class EthereumTxAck extends jspb.Message {
  hasDataChunk(): boolean;
  clearDataChunk(): void;
  getDataChunk(): Uint8Array | string;
  getDataChunk_asU8(): Uint8Array;
  getDataChunk_asB64(): string;
  setDataChunk(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumTxAck.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumTxAck): EthereumTxAck.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumTxAck, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumTxAck;
  static deserializeBinaryFromReader(message: EthereumTxAck, reader: jspb.BinaryReader): EthereumTxAck;
}

export namespace EthereumTxAck {
  export type AsObject = {
    dataChunk: Uint8Array | string,
  }
}

export class EthereumSignMessage extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasMessage(): boolean;
  clearMessage(): void;
  getMessage(): Uint8Array | string;
  getMessage_asU8(): Uint8Array;
  getMessage_asB64(): string;
  setMessage(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumSignMessage.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumSignMessage): EthereumSignMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumSignMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumSignMessage;
  static deserializeBinaryFromReader(message: EthereumSignMessage, reader: jspb.BinaryReader): EthereumSignMessage;
}

export namespace EthereumSignMessage {
  export type AsObject = {
    addressNList: Array<number>,
    message: Uint8Array | string,
  }
}

export class EthereumVerifyMessage extends jspb.Message {
  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): Uint8Array | string;
  getAddress_asU8(): Uint8Array;
  getAddress_asB64(): string;
  setAddress(value: Uint8Array | string): void;

  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  hasMessage(): boolean;
  clearMessage(): void;
  getMessage(): Uint8Array | string;
  getMessage_asU8(): Uint8Array;
  getMessage_asB64(): string;
  setMessage(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumVerifyMessage.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumVerifyMessage): EthereumVerifyMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumVerifyMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumVerifyMessage;
  static deserializeBinaryFromReader(message: EthereumVerifyMessage, reader: jspb.BinaryReader): EthereumVerifyMessage;
}

export namespace EthereumVerifyMessage {
  export type AsObject = {
    address: Uint8Array | string,
    signature: Uint8Array | string,
    message: Uint8Array | string,
  }
}

export class EthereumMessageSignature extends jspb.Message {
  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): Uint8Array | string;
  getAddress_asU8(): Uint8Array;
  getAddress_asB64(): string;
  setAddress(value: Uint8Array | string): void;

  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumMessageSignature.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumMessageSignature): EthereumMessageSignature.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumMessageSignature, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumMessageSignature;
  static deserializeBinaryFromReader(message: EthereumMessageSignature, reader: jspb.BinaryReader): EthereumMessageSignature;
}

export namespace EthereumMessageSignature {
  export type AsObject = {
    address: Uint8Array | string,
    signature: Uint8Array | string,
  }
}

export class EthereumSignTypedHash extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasDomainSeparatorHash(): boolean;
  clearDomainSeparatorHash(): void;
  getDomainSeparatorHash(): Uint8Array | string;
  getDomainSeparatorHash_asU8(): Uint8Array;
  getDomainSeparatorHash_asB64(): string;
  setDomainSeparatorHash(value: Uint8Array | string): void;

  hasMessageHash(): boolean;
  clearMessageHash(): void;
  getMessageHash(): Uint8Array | string;
  getMessageHash_asU8(): Uint8Array;
  getMessageHash_asB64(): string;
  setMessageHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumSignTypedHash.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumSignTypedHash): EthereumSignTypedHash.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumSignTypedHash, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumSignTypedHash;
  static deserializeBinaryFromReader(message: EthereumSignTypedHash, reader: jspb.BinaryReader): EthereumSignTypedHash;
}

export namespace EthereumSignTypedHash {
  export type AsObject = {
    addressNList: Array<number>,
    domainSeparatorHash: Uint8Array | string,
    messageHash: Uint8Array | string,
  }
}

export class EthereumTypedDataSignature extends jspb.Message {
  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): string | undefined;
  setAddress(value: string): void;

  hasDomainSeparatorHash(): boolean;
  clearDomainSeparatorHash(): void;
  getDomainSeparatorHash(): Uint8Array | string;
  getDomainSeparatorHash_asU8(): Uint8Array;
  getDomainSeparatorHash_asB64(): string;
  setDomainSeparatorHash(value: Uint8Array | string): void;

  hasHasMsgHash(): boolean;
  clearHasMsgHash(): void;
  getHasMsgHash(): boolean | undefined;
  setHasMsgHash(value: boolean): void;

  hasMessageHash(): boolean;
  clearMessageHash(): void;
  getMessageHash(): Uint8Array | string;
  getMessageHash_asU8(): Uint8Array;
  getMessageHash_asB64(): string;
  setMessageHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EthereumTypedDataSignature.AsObject;
  static toObject(includeInstance: boolean, msg: EthereumTypedDataSignature): EthereumTypedDataSignature.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EthereumTypedDataSignature, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EthereumTypedDataSignature;
  static deserializeBinaryFromReader(message: EthereumTypedDataSignature, reader: jspb.BinaryReader): EthereumTypedDataSignature;
}

export namespace EthereumTypedDataSignature {
  export type AsObject = {
    signature: Uint8Array | string,
    address?: string,
    domainSeparatorHash: Uint8Array | string,
    hasMsgHash?: boolean,
    messageHash: Uint8Array | string,
  }
}

export class Ethereum712TypesValues extends jspb.Message {
  clearAddressNList(): void;
  getAddressNList(): Array<number>;
  setAddressNList(value: Array<number>): void;
  addAddressN(value: number, index?: number): number;

  hasEip712types(): boolean;
  clearEip712types(): void;
  getEip712types(): string | undefined;
  setEip712types(value: string): void;

  hasEip712primetype(): boolean;
  clearEip712primetype(): void;
  getEip712primetype(): string | undefined;
  setEip712primetype(value: string): void;

  hasEip712data(): boolean;
  clearEip712data(): void;
  getEip712data(): string | undefined;
  setEip712data(value: string): void;

  hasEip712typevals(): boolean;
  clearEip712typevals(): void;
  getEip712typevals(): number | undefined;
  setEip712typevals(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Ethereum712TypesValues.AsObject;
  static toObject(includeInstance: boolean, msg: Ethereum712TypesValues): Ethereum712TypesValues.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Ethereum712TypesValues, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Ethereum712TypesValues;
  static deserializeBinaryFromReader(message: Ethereum712TypesValues, reader: jspb.BinaryReader): Ethereum712TypesValues;
}

export namespace Ethereum712TypesValues {
  export type AsObject = {
    addressNList: Array<number>,
    eip712types?: string,
    eip712primetype?: string,
    eip712data?: string,
    eip712typevals?: number,
  }
}

