"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBnbTx = exports.validateBnbTx = exports.decodeBnbTx = void 0;
const bnbSdk = __importStar(require("bnb-javascript-sdk-nobroadcast"));
const crypto_js_1 = __importDefault(require("crypto-js"));
const tiny_secp256k1_1 = __importDefault(require("tiny-secp256k1"));
function decodeBnbTx(txBytes, chainId) {
    const txDecoded = bnbSdk.amino.decoder.unMarshalBinaryLengthPrefixed(txBytes, {
        aminoPrefix: "f0625dee",
        msgs: [
            {
                aminoPrefix: "2a2c87fa",
                inputs: [{ address: Buffer.alloc(0), coins: [{ denom: "", amount: 0 }] }],
                outputs: [{ address: Buffer.alloc(0), coins: [{ denom: "", amount: 0 }] }],
            },
        ],
        signatures: [
            {
                pubKey: Buffer.alloc(0),
                signature: Buffer.alloc(0),
                accountNumber: 0,
                sequence: 0,
            },
        ],
        memo: "",
        source: 0,
        data: Buffer.alloc(0),
    }).val;
    if (txDecoded.data !== null)
        throw new Error("bad data length");
    if (txDecoded.msgs.length !== 1)
        throw new Error("bad msgs length");
    if (txDecoded.signatures.length !== 1)
        throw new Error("bad signatures length");
    const signBytes = JSON.stringify({
        account_number: String(txDecoded.signatures[0].accountNumber),
        chain_id: chainId,
        data: null,
        memo: txDecoded.memo,
        msgs: [
            {
                inputs: txDecoded.msgs[0].inputs.map((x) => ({
                    address: bnbSdk.crypto.encodeAddress(x.address, "bnb"),
                    coins: x.coins.map((y) => ({
                        amount: Number(y.amount),
                        denom: y.denom,
                    })),
                })),
                outputs: txDecoded.msgs[0].outputs.map((x) => ({
                    address: bnbSdk.crypto.encodeAddress(x.address, "bnb"),
                    coins: x.coins.map((y) => ({
                        amount: Number(y.amount),
                        denom: y.denom,
                    })),
                })),
            },
        ],
        sequence: String(txDecoded.signatures[0].sequence),
        source: String(txDecoded.source),
    });
    const signBytesHash = crypto_js_1.default.SHA256(crypto_js_1.default.enc.Utf8.parse(signBytes)).toString();
    const pubKeyAmino = Buffer.from(txDecoded.signatures[0].pubKey);
    if (pubKeyAmino.readUInt32BE(0) !== 0xeb5ae987)
        throw new Error("bad pubkey aminoPrefix");
    if (pubKeyAmino.readUInt8(4) !== 33)
        throw new Error("bad pubKey length");
    const pubKey = pubKeyAmino.slice(5);
    const signature = txDecoded.signatures[0].signature;
    return { signBytes, signBytesHash, pubKey, signature };
}
exports.decodeBnbTx = decodeBnbTx;
function validateBnbTx(txBytes, chainId) {
    const { signBytesHash, pubKey, signature } = decodeBnbTx(txBytes, chainId);
    return tiny_secp256k1_1.default.verify(Buffer.from(signBytesHash, "hex"), pubKey, signature);
}
exports.validateBnbTx = validateBnbTx;
function encodeBnbTx(unsignedTx, publicKey, signature) {
    const { account_number, chain_id, sequence, source } = unsignedTx;
    const msg = unsignedTx.msgs[0];
    const amountToInt = (x) => Number(x);
    const msgNormalizer = (x) => ({
        address: bnbSdk.crypto.decodeAddress(x.address),
        coins: x.coins.map((y) => ({
            // In particular, these keys are backwards because we can't have nice things.
            denom: y.denom,
            amount: amountToInt(y.amount),
        })),
    });
    const baseMsg = {
        inputs: msg.inputs.map(msgNormalizer),
        outputs: msg.outputs.map(msgNormalizer),
        aminoPrefix: "2A2C87FA",
    };
    const tx = new bnbSdk.Transaction(Object.assign({}, unsignedTx, {
        chainId: chain_id,
        accountNumber: Number(account_number),
        source: Number(source !== null && source !== void 0 ? source : 0),
        sequence: Number(sequence),
        // A bug in the binance SDK makes this field required, even though it shouldn't be.
        baseMsg: { getMsg: () => baseMsg, getBaseMsg: () => baseMsg, getSignMsg: () => baseMsg },
    }));
    const ecPubKey = bnbSdk.crypto.getPublicKey(Buffer.from(publicKey).toString("hex"));
    tx.addSignature(ecPubKey, signature);
    const serializedTx = Buffer.from(tx.serialize(), "hex");
    if (!validateBnbTx(serializedTx, chain_id))
        throw new Error("serialized tx did not validate");
    return serializedTx;
}
exports.encodeBnbTx = encodeBnbTx;
//# sourceMappingURL=bnbencoding.js.map