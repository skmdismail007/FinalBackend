"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.info = exports.KeepKeyHDWallet = exports.KeepKeyHDWalletInfo = exports.isKeepKey = void 0;
const Messages = __importStar(require("@keepkey/device-protocol/lib/messages_pb"));
const Types = __importStar(require("@keepkey/device-protocol/lib/types_pb"));
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const lodash_1 = __importDefault(require("lodash"));
const semver_1 = __importDefault(require("semver"));
const Binance = __importStar(require("./binance"));
const Btc = __importStar(require("./bitcoin"));
const Cosmos = __importStar(require("./cosmos"));
const Eos = __importStar(require("./eos"));
const Eth = __importStar(require("./ethereum"));
const Osmosis = __importStar(require("./osmosis"));
const Ripple = __importStar(require("./ripple"));
const Thorchain = __importStar(require("./thorchain"));
const typeRegistry_1 = require("./typeRegistry");
const utils_1 = require("./utils");
function isKeepKey(wallet) {
    return lodash_1.default.isObject(wallet) && wallet._isKeepKey;
}
exports.isKeepKey = isKeepKey;
function describeETHPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Ethereum",
        isKnown: false,
    };
    if (path.length != 5)
        return unknown;
    if (path[0] != 0x80000000 + 44)
        return unknown;
    if (path[1] != 0x80000000 + core.slip44ByCoin("Ethereum"))
        return unknown;
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000)
        return unknown;
    if (path[3] != 0)
        return unknown;
    if (path[4] != 0)
        return unknown;
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Ethereum Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Ethereum",
        isKnown: true,
        isPrefork: false,
    };
}
function describeUTXOPath(path, coin, scriptType) {
    var _a;
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin,
        scriptType,
        isKnown: false,
    };
    if (!scriptType)
        return unknown;
    if (!Btc.btcSupportsCoin(coin))
        return unknown;
    if (!Btc.btcSupportsScriptType(coin, scriptType))
        return unknown;
    if (path.length !== 3 && path.length !== 5)
        return unknown;
    if ((path[0] & 0x80000000) >>> 0 !== 0x80000000)
        return unknown;
    const purpose = path[0] & 0x7fffffff;
    if (![44, 49, 84].includes(purpose))
        return unknown;
    if (purpose === 44 && scriptType !== core.BTCInputScriptType.SpendAddress)
        return unknown;
    if (purpose === 49 && scriptType !== core.BTCInputScriptType.SpendP2SHWitness)
        return unknown;
    if (purpose === 84 && scriptType !== core.BTCInputScriptType.SpendWitness)
        return unknown;
    const wholeAccount = path.length === 3;
    const script = scriptType
        ? (_a = {
            [core.BTCInputScriptType.SpendAddress]: ["Legacy"],
            [core.BTCInputScriptType.SpendP2SHWitness]: [],
            [core.BTCInputScriptType.SpendWitness]: ["Segwit Native"],
        }[scriptType]) !== null && _a !== void 0 ? _a : []
        : [];
    let isPrefork = false;
    const slip44 = core.slip44ByCoin(coin);
    if (slip44 === undefined)
        return unknown;
    if (path[1] !== 0x80000000 + slip44) {
        switch (coin) {
            case "BitcoinCash":
            case "BitcoinGold": {
                if (path[1] === 0x80000000 + core.slip44ByCoin("Bitcoin")) {
                    isPrefork = true;
                    break;
                }
                return unknown;
            }
            case "BitcoinSV": {
                if (path[1] === 0x80000000 + core.slip44ByCoin("Bitcoin") ||
                    path[1] === 0x80000000 + core.slip44ByCoin("BitcoinCash")) {
                    isPrefork = true;
                    break;
                }
                return unknown;
            }
            default:
                return unknown;
        }
    }
    let attributes = isPrefork ? ["Prefork"] : [];
    switch (coin) {
        case "Bitcoin":
        case "Litecoin":
        case "BitcoinGold":
        case "Testnet": {
            attributes = attributes.concat(script);
            break;
        }
        default:
            break;
    }
    const attr = attributes.length ? ` (${attributes.join(", ")})` : "";
    const accountIdx = path[2] & 0x7fffffff;
    if (wholeAccount) {
        return {
            coin,
            verbose: `${coin} Account #${accountIdx}${attr}`,
            accountIdx,
            wholeAccount: true,
            isKnown: true,
            scriptType,
            isPrefork,
        };
    }
    else {
        const change = path[3] === 1 ? "Change " : "";
        const addressIdx = path[4];
        return {
            coin,
            verbose: `${coin} Account #${accountIdx}, ${change}Address #${addressIdx}${attr}`,
            accountIdx,
            addressIdx,
            wholeAccount: false,
            isKnown: true,
            isChange: path[3] === 1,
            scriptType,
            isPrefork,
        };
    }
}
function describeCosmosPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Atom",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Atom")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Cosmos Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Atom",
        isKnown: true,
        isPrefork: false,
    };
}
function describeOsmosisPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Osmo",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Osmo")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Osmosis Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Osmo",
        isKnown: true,
        isPrefork: false,
    };
}
function describeThorchainPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Rune",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Rune")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `THORChain Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Rune",
        isKnown: true,
        isPrefork: false,
    };
}
function describeEosPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Eos",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Eos")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Eos Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Eos",
        isKnown: true,
        isPrefork: false,
    };
}
function describeRipplePath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Ripple",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Ripple")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Ripple Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Ripple",
        isKnown: true,
        isPrefork: false,
    };
}
function describeBinancePath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Binance",
        isKnown: false,
    };
    if (path.length != 5) {
        return unknown;
    }
    if (path[0] != 0x80000000 + 44) {
        return unknown;
    }
    if (path[1] != 0x80000000 + core.slip44ByCoin("Binance")) {
        return unknown;
    }
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000) {
        return unknown;
    }
    if (path[3] !== 0 || path[4] !== 0) {
        return unknown;
    }
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Binance Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Binance",
        isKnown: true,
        isPrefork: false,
    };
}
class KeepKeyHDWalletInfo {
    constructor() {
        this._supportsBTCInfo = true;
        this._supportsETHInfo = true;
        this._supportsCosmosInfo = true;
        this._supportsOsmosisInfo = true;
        this._supportsRippleInfo = true;
        this._supportsBinanceInfo = true;
        this._supportsEosInfo = true;
        this._supportsThorchainInfo = true;
    }
    getVendor() {
        return "KeepKey";
    }
    btcSupportsCoin(coin) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcSupportsCoin(coin);
        });
    }
    btcSupportsScriptType(coin, scriptType) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcSupportsScriptType(coin, scriptType);
        });
    }
    btcSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcSupportsSecureTransfer();
        });
    }
    btcSupportsNativeShapeShift() {
        return Btc.btcSupportsNativeShapeShift();
    }
    btcGetAccountPaths(msg) {
        return Btc.btcGetAccountPaths(msg);
    }
    btcIsSameAccount(msg) {
        return Btc.btcIsSameAccount(msg);
    }
    ethSupportsNetwork(chain_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethSupportsNetwork(chain_id);
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethSupportsSecureTransfer();
        });
    }
    ethSupportsNativeShapeShift() {
        return Eth.ethSupportsNativeShapeShift();
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    ethGetAccountPaths(msg) {
        return Eth.ethGetAccountPaths(msg);
    }
    cosmosGetAccountPaths(msg) {
        return Cosmos.cosmosGetAccountPaths(msg);
    }
    osmosisGetAccountPaths(msg) {
        return Osmosis.osmosisGetAccountPaths(msg);
    }
    thorchainGetAccountPaths(msg) {
        return Thorchain.thorchainGetAccountPaths(msg);
    }
    rippleGetAccountPaths(msg) {
        return Ripple.rippleGetAccountPaths(msg);
    }
    binanceGetAccountPaths(msg) {
        return Binance.binanceGetAccountPaths(msg);
    }
    eosGetAccountPaths(msg) {
        return Eos.eosGetAccountPaths(msg);
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return false;
    }
    hasOnDeviceDisplay() {
        return true;
    }
    hasOnDeviceRecovery() {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hasNativeShapeShift(srcCoin, dstCoin) {
        return true;
    }
    supportsBip44Accounts() {
        return true;
    }
    supportsOfflineSigning() {
        return true;
    }
    supportsBroadcast() {
        return false;
    }
    describePath(msg) {
        switch (msg.coin) {
            case "Ethereum":
                return describeETHPath(msg.path);
            case "Atom":
                return describeCosmosPath(msg.path);
            case "Osmo":
                return describeOsmosisPath(msg.path);
            case "Binance":
                return describeBinancePath(msg.path);
            case "Ripple":
                return describeRipplePath(msg.path);
            case "Eos":
                return describeEosPath(msg.path);
            default:
                return describeUTXOPath(msg.path, msg.coin, msg.scriptType);
        }
    }
    btcNextAccountPath(msg) {
        const description = describeUTXOPath(msg.addressNList, msg.coin, msg.scriptType);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        if (addressNList[0] === 0x80000000 + 44 ||
            addressNList[0] === 0x80000000 + 49 ||
            addressNList[0] === 0x80000000 + 84) {
            addressNList[2] += 1;
            return Object.assign(Object.assign({}, msg), { addressNList });
        }
        return undefined;
    }
    ethNextAccountPath(msg) {
        const addressNList = msg.hardenedPath.concat(msg.relPath);
        const description = describeETHPath(addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        if (addressNList[0] === 0x80000000 + 44) {
            addressNList[2] += 1;
            return Object.assign(Object.assign({}, msg), { addressNList, hardenedPath: core.hardenedPath(addressNList), relPath: core.relativePath(addressNList) });
        }
        return undefined;
    }
    cosmosNextAccountPath(msg) {
        const description = describeCosmosPath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
    osmosisNextAccountPath(msg) {
        const description = describeOsmosisPath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
    thorchainNextAccountPath(msg) {
        const description = describeThorchainPath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
    rippleNextAccountPath(msg) {
        const description = describeRipplePath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
    binanceNextAccountPath(msg) {
        const description = describeBinancePath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
    eosNextAccountPath(msg) {
        const description = describeEosPath(msg.addressNList);
        if (!description.isKnown) {
            return undefined;
        }
        const addressNList = msg.addressNList;
        addressNList[2] += 1;
        return Object.assign(Object.assign({}, msg), { addressNList });
    }
}
exports.KeepKeyHDWalletInfo = KeepKeyHDWalletInfo;
class KeepKeyHDWallet {
    constructor(transport) {
        this._supportsETHInfo = true;
        this._supportsBTCInfo = true;
        this._supportsCosmosInfo = true;
        this._supportsOsmosisInfo = true;
        this._supportsRippleInfo = true;
        this._supportsBinanceInfo = true;
        this._supportsEosInfo = true;
        this._supportsFioInfo = false;
        this._isKeepKey = true;
        this._supportsETH = true;
        this._supportsEthSwitchChain = false;
        this._supportsAvalanche = false;
        this._supportsOptimism = false;
        this._supportsBSC = false;
        this._supportsBTC = true;
        this._supportsCosmos = true;
        this._supportsOsmosis = true;
        this._supportsRipple = true;
        this._supportsBinance = true;
        this._supportsEos = true;
        this._supportsFio = false;
        this._supportsThorchainInfo = true;
        this._supportsThorchain = true;
        this._supportsSecretInfo = false;
        this._supportsSecret = false;
        this._supportsKava = false;
        this._supportsKavaInfo = false;
        this._supportsTerra = false;
        this._supportsTerraInfo = false;
        this.transport = transport;
        this._supportsDebugLink = transport.debugLink;
        this.info = new KeepKeyHDWalletInfo();
    }
    static create(transport) {
        return __awaiter(this, void 0, void 0, function* () {
            return new KeepKeyHDWallet(transport);
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            const featuresId = (yield this.getFeatures(/*cached=*/ true)).deviceId;
            // Devices in bootloader mode show up with empty string deviceId's in their features object.
            if (featuresId)
                return featuresId;
            // Grabbing the one from the transport seems to be a reasonable fallback.
            return yield this.transport.getDeviceID();
        });
    }
    getVendor() {
        return "KeepKey";
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            return core.mustBeDefined((yield this.getFeatures(/*cached=*/ true)).model);
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures(/*cached=*/ true);
            return `v${features.majorVersion}.${features.minorVersion}.${features.patchVersion}`;
        });
    }
    getLabel() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = (yield this.getFeatures(/*cached=*/ true)).label) !== null && _a !== void 0 ? _a : "";
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getFeatures()).initialized;
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            if (features.pinProtection && !features.pinCached)
                return true;
            if (features.passphraseProtection && !features.passphraseCached)
                return true;
            return false;
        });
    }
    getPublicKeys(getPublicKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKeys = [];
            for (let i = 0; i < getPublicKeys.length; i++) {
                const { coin, addressNList, curve, showDisplay, scriptType } = getPublicKeys[i];
                const GPK = new Messages.GetPublicKey();
                if (coin)
                    GPK.setCoinName(coin);
                GPK.setAddressNList(addressNList);
                GPK.setShowDisplay(showDisplay || false);
                GPK.setEcdsaCurveName(curve || "secp256k1");
                GPK.setScriptType(utils_1.translateInputScriptType(scriptType || core.BTCInputScriptType.SpendAddress));
                const event = yield this.transport.call(Messages.MessageType.MESSAGETYPE_GETPUBLICKEY, GPK, {
                    msgTimeout: showDisplay ? core.LONG_TIMEOUT : core.DEFAULT_TIMEOUT,
                });
                const publicKey = event.proto;
                publicKeys.push({ xpub: core.mustBeDefined(publicKey.getXpub()) });
            }
            return publicKeys;
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const ping = new Messages.Ping();
            ping.setMessage(msg.msg);
            ping.setButtonProtection(msg.button || false);
            ping.setPinProtection(msg.pin || false);
            ping.setPassphraseProtection(msg.passphrase || false);
            const event = yield this.transport.call(Messages.MessageType.MESSAGETYPE_PING, ping, {
                msgTimeout: msg.button || msg.pin || msg.passphrase ? core.LONG_TIMEOUT : core.DEFAULT_TIMEOUT,
            });
            const message = event.proto;
            return { msg: core.mustBeDefined(message.getMessage()) };
        });
    }
    reset(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const resetDevice = new Messages.ResetDevice();
            resetDevice.setStrength(msg.entropy || 128);
            resetDevice.setDisplayRandom(false);
            resetDevice.setPassphraseProtection(msg.passphrase || false);
            resetDevice.setPinProtection(msg.pin || false);
            resetDevice.setLabel(msg.label);
            if (msg.autoLockDelayMs) {
                resetDevice.setAutoLockDelayMs(msg.autoLockDelayMs);
            }
            resetDevice.setU2fCounter(msg.u2fCounter || Math.floor(+new Date() / 1000));
            // resetDevice.setWordsPerGape(wordsPerScreen) // Re-enable when patch gets in
            // Send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_RESETDEVICE, resetDevice, {
                msgTimeout: core.LONG_TIMEOUT,
            });
            this.cacheFeatures(undefined);
        });
    }
    recover(r) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new Messages.RecoveryDevice();
            msg.setWordCount({ 128: 12, 192: 18, 256: 24 }[r.entropy]);
            msg.setPassphraseProtection(r.passphrase);
            msg.setPinProtection(r.pin);
            msg.setLabel(r.label);
            msg.setLanguage(r.language || "english");
            msg.setEnforceWordlist(true);
            msg.setUseCharacterCipher(true);
            if (r.autoLockDelayMs) {
                msg.setAutoLockDelayMs(r.autoLockDelayMs);
            }
            msg.setU2fCounter(r.u2fCounter || Math.floor(+new Date() / 1000));
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_RECOVERYDEVICE, msg, {
                msgTimeout: core.LONG_TIMEOUT,
            });
            this.cacheFeatures(undefined);
        });
    }
    pressYes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.press(true);
        });
    }
    pressNo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.press(false);
        });
    }
    press(isYes) {
        return __awaiter(this, void 0, void 0, function* () {
            const decision = new Messages.DebugLinkDecision();
            decision.setYesNo(isYes);
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_DEBUGLINKDECISION, decision, {
                noWait: true,
                debugLink: true,
            });
        });
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return false;
    }
    hasOnDeviceDisplay() {
        return true;
    }
    hasOnDeviceRecovery() {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hasNativeShapeShift(srcCoin, dstCoin) {
        return true;
    }
    supportsBip44Accounts() {
        return this.info.supportsBip44Accounts();
    }
    supportsOfflineSigning() {
        return true;
    }
    supportsBroadcast() {
        return false;
    }
    sendPin(pin) {
        return __awaiter(this, void 0, void 0, function* () {
            const matrixAck = new Messages.PinMatrixAck();
            matrixAck.setPin(pin);
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_PINMATRIXACK, matrixAck, {
                msgTimeout: core.DEFAULT_TIMEOUT,
                omitLock: true,
                noWait: true,
            });
        });
    }
    sendPassphrase(passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const passphraseAck = new Messages.PassphraseAck();
            passphraseAck.setPassphrase(passphrase);
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_PASSPHRASEACK, passphraseAck, {
                msgTimeout: core.DEFAULT_TIMEOUT,
                omitLock: true,
                noWait: true,
            });
        });
    }
    sendCharacter(character) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sendCharacterProto(character, false, false);
        });
    }
    sendCharacterDelete() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sendCharacterProto("", true, false);
        });
    }
    sendCharacterDone() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sendCharacterProto("", false, true);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendWord(word) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not Yet Implemented :(");
        });
    }
    sendCharacterProto(character, _delete, _done) {
        return __awaiter(this, void 0, void 0, function* () {
            const characterAck = new Messages.CharacterAck();
            if (character !== "") {
                characterAck.setCharacter(character);
            }
            else if (_delete) {
                characterAck.setDelete(_delete);
            }
            else if (_done) {
                characterAck.setDone(_done);
            }
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_CHARACTERACK, characterAck, {
                msgTimeout: core.DEFAULT_TIMEOUT,
                omitLock: true,
                noWait: true,
            });
        });
    }
    // ApplyPolicy enables or disables a named policy such as "ShapeShift" on the device
    applyPolicy(p) {
        return __awaiter(this, void 0, void 0, function* () {
            const policy = new Types.PolicyType();
            policy.setPolicyName(p.policyName);
            policy.setEnabled(p.enabled);
            const applyPolicies = new Messages.ApplyPolicies();
            applyPolicies.setPolicyList([policy]);
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_APPLYPOLICIES, applyPolicies, {
                msgTimeout: core.LONG_TIMEOUT,
            });
            this.cacheFeatures(undefined);
        });
    }
    // ApplySettings changes the label, language, and enabling/disabling the passphrase
    // The default language is english
    applySettings(s) {
        return __awaiter(this, void 0, void 0, function* () {
            const applySettings = new Messages.ApplySettings();
            if (s.label) {
                applySettings.setLabel(s.label);
            }
            if (s.language) {
                applySettings.setLanguage(s.language);
            }
            if (s.usePassphrase !== undefined) {
                applySettings.setUsePassphrase(s.usePassphrase);
            }
            if (s.autoLockDelayMs) {
                applySettings.setAutoLockDelayMs(s.autoLockDelayMs);
            }
            if (s.u2fCounter) {
                applySettings.setU2fCounter(s.u2fCounter);
            }
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_APPLYSETTINGS, applySettings);
            this.cacheFeatures(undefined);
        });
    }
    // Cancel aborts the last device action that required user interaction
    // It can follow a button request, passphrase request, or pin request
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.transport.cancel();
        });
    }
    // ChangePin requests setting/changing the pin
    changePin() {
        return __awaiter(this, void 0, void 0, function* () {
            const changePin = new Messages.ChangePin();
            // User may be propmpted for button press up to 2 times
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_CHANGEPIN, changePin, {
                msgTimeout: core.LONG_TIMEOUT,
            });
        });
    }
    // CipherKeyValue encrypts or decrypts a value with a given key, nodepath, and initializationVector
    // This method encrypts if encrypt is true and decrypts if false, the confirm paramater determines wether
    // the user is prompted on the device. See EncryptKeyValue() and DecryptKeyValue() for convenience methods
    // NOTE: If the length of the value in bytes is not divisible by 16 it will be zero padded
    cipherKeyValue(v) {
        return __awaiter(this, void 0, void 0, function* () {
            // if(val.length % 16 !== 0) val = val.concat() TODO THIS
            const cipherKeyValue = new Messages.CipherKeyValue();
            cipherKeyValue.setAddressNList(v.addressNList);
            cipherKeyValue.setKey(v.key);
            cipherKeyValue.setValue(v.value);
            cipherKeyValue.setEncrypt(!!v.encrypt);
            cipherKeyValue.setAskOnEncrypt(v.askOnEncrypt || false);
            cipherKeyValue.setAskOnDecrypt(v.askOnDecrypt || false);
            cipherKeyValue.setIv(v.iv || "");
            const response = yield this.transport.call(Messages.MessageType.MESSAGETYPE_CIPHERKEYVALUE, cipherKeyValue);
            const ckv = response.message;
            return ckv.getValue();
        });
    }
    // ClearSession clears cached session values such as the pin and passphrase
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () {
            const clearSession = new Messages.ClearSession();
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_CLEARSESSION, clearSession);
            this.cacheFeatures(undefined);
        });
    }
    // DecryptKeyValue is a convenience method around decrypting with CipherKeyValue().
    // For more granular control of the process use CipherKeyValue()
    decryptKeyValue(v) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cipherKeyValue(v);
        });
    }
    // FirmwareErase askes the device to erase its firmware
    firmwareErase() {
        return __awaiter(this, void 0, void 0, function* () {
            const firmwareErase = new Messages.FirmwareErase();
            // send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_FIRMWAREERASE, firmwareErase);
            this.cacheFeatures(undefined);
        });
    }
    firmwareUpload(firmware) {
        return __awaiter(this, void 0, void 0, function* () {
            const firmwareUpload = new Messages.FirmwareUpload();
            const hash = yield this.transport.getFirmwareHash(firmware);
            firmwareUpload.setPayload(firmware);
            firmwareUpload.setPayloadHash(hash);
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_FIRMWAREUPLOAD, firmwareUpload);
            this.cacheFeatures(undefined);
        });
    }
    // Initialize assigns a hid connection to this KeepKey and send initialize message to device
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const initialize = new Messages.Initialize();
            const event = yield this.transport.call(Messages.MessageType.MESSAGETYPE_INITIALIZE, initialize);
            if (!event.message)
                throw event;
            const out = event.message;
            this.features = out;
            // v6.1.0 firmware changed usb serial numbers to match STM32 desig_device_id
            // If the deviceId in the features table doesn't match, then we need to
            // add another k-v pair to the keyring so it can be looked up either way.
            const transportDeviceID = yield this.transport.getDeviceID();
            if (out.deviceId && transportDeviceID !== out.deviceId) {
                this.transport.keyring.addAlias(transportDeviceID, out.deviceId);
            }
            const fwVersion = `v${out.majorVersion}.${out.minorVersion}.${out.patchVersion}`;
            //Lost Support per proto 44.3
            this._supportsOsmosis = semver_1.default.gte(fwVersion, "v7.7.0");
            this._supportsCosmos = semver_1.default.gte(fwVersion, "v7.3.0");
            this._supportsRipple = semver_1.default.gte(fwVersion, "v6.4.0");
            this._supportsBinance = semver_1.default.gte(fwVersion, "v6.4.0");
            this._supportsEos = semver_1.default.gte(fwVersion, "v6.4.0");
            // this._supportsThorchain = semver.get(fwVersion, "v7.3.0");
            this.cacheFeatures(out);
            return out;
        });
    }
    // GetFeatures returns the features and other device information such as the version, label, and supported coins
    getFeatures(cached = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cached && this.featuresCache)
                return this.featuresCache;
            const features = new Messages.GetFeatures();
            const event = yield this.transport.call(Messages.MessageType.MESSAGETYPE_GETFEATURES, features);
            this.cacheFeatures(event.message);
            return event.message;
        });
    }
    cacheFeatures(features) {
        this.featuresCache = features;
    }
    // GetEntropy requests sample data from the hardware RNG
    getEntropy(size) {
        return __awaiter(this, void 0, void 0, function* () {
            const getEntropy = new Messages.GetEntropy();
            getEntropy.setSize(size);
            // send
            const event = yield this.transport.call(Messages.MessageType.MESSAGETYPE_GETENTROPY, getEntropy, {
                msgTimeout: core.LONG_TIMEOUT,
            });
            return core.mustBeDefined(event.proto).getEntropy_asU8();
        });
    }
    // GetNumCoins returns the number of coins supported by the device regardless of if the hanve funds.
    getNumCoins() {
        return __awaiter(this, void 0, void 0, function* () {
            const getCoinTable = new Messages.GetCoinTable();
            const response = yield this.transport.call(Messages.MessageType.MESSAGETYPE_GETCOINTABLE, getCoinTable);
            return core.mustBeDefined(core.mustBeDefined(response.proto).getNumCoins());
        });
    }
    // GetCoinTable returns an array of Types.CoinTypes, with start and end arguments for paging.
    // You cannot request more than 10 at a time.
    getCoinTable(start = 0, end = start + 10) {
        return __awaiter(this, void 0, void 0, function* () {
            const getCoinTable = new Messages.GetCoinTable();
            getCoinTable.setStart(start);
            getCoinTable.setEnd(end);
            const response = yield this.transport.call(Messages.MessageType.MESSAGETYPE_GETCOINTABLE, getCoinTable);
            const coinTable = response.message;
            return coinTable.tableList;
        });
    }
    // LoadDevice loads a provided seed onto the device and applies the provided settings
    // including setting a pin/device label, enabling/disabling the passphrase, and whether to
    // check the checksum of the provided mnemonic
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const loadDevice = new Messages.LoadDevice();
            loadDevice.setMnemonic(msg.mnemonic);
            loadDevice.setPassphraseProtection(!!msg.passphrase);
            loadDevice.setSkipChecksum(!!msg.skipChecksum);
            if (msg.pin)
                loadDevice.setPin(msg.pin);
            if (msg.label)
                loadDevice.setLabel(msg.label);
            // send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_LOADDEVICE, loadDevice, {
                msgTimeout: core.LONG_TIMEOUT,
            });
            this.cacheFeatures(undefined);
        });
    }
    // RemovePin disables pin protection for the device. If a pin is currently enabled
    // it will prompt the user to enter the current pin
    removePin() {
        return __awaiter(this, void 0, void 0, function* () {
            const changePin = new Messages.ChangePin();
            changePin.setRemove(true);
            // send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_CHANGEPIN, changePin);
            this.cacheFeatures(undefined);
        });
    }
    send(events) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const event of events) {
                const MessageType = typeRegistry_1.messageTypeRegistry[core.mustBeDefined(event.message_enum)];
                const msg = new MessageType();
                Object.entries(event.message).forEach(([key, value]) => {
                    const setterMethod = utils_1.protoFieldToSetMethod(key);
                    if (msg[setterMethod]) {
                        // Assume setter methods are always of the format: strength -> setStrength
                        // until this exists https://github.com/protocolbuffers/protobuf/issues/1591
                        msg[setterMethod](value);
                    }
                });
                yield this.transport.call(core.mustBeDefined(event.message_enum), msg);
            }
        });
    }
    // SoftReset power cycles the device. The device only responds to
    // this message while in manufacturer mode
    softReset() {
        return __awaiter(this, void 0, void 0, function* () {
            const softReset = new Messages.SoftReset();
            // send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_SOFTRESET, softReset);
            this.cacheFeatures(undefined);
        });
    }
    // WipeDevice wipes all sensitive data and settings
    wipe() {
        return __awaiter(this, void 0, void 0, function* () {
            const wipeDevice = new Messages.WipeDevice();
            // send
            yield this.transport.call(Messages.MessageType.MESSAGETYPE_WIPEDEVICE, wipeDevice);
            this.cacheFeatures(undefined);
        });
    }
    btcSupportsCoin(coin) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.info.btcSupportsCoin(coin);
        });
    }
    btcSupportsScriptType(coin, scriptType) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.info.btcSupportsScriptType(coin, scriptType);
        });
    }
    btcGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcGetAddress(this, this.transport, msg);
        });
    }
    btcSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcSignTx(this, this.transport, msg);
        });
    }
    btcSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.info.btcSupportsSecureTransfer();
        });
    }
    btcSupportsNativeShapeShift() {
        return this.info.btcSupportsNativeShapeShift();
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            // EIP1559 support starts in v7.2.1
            return semver_1.default.gte(yield this.getFirmwareVersion(), "v7.2.1");
        });
    }
    btcSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcSignMessage(this, this.transport, msg);
        });
    }
    btcVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Btc.btcVerifyMessage(this, this.transport, msg);
        });
    }
    btcGetAccountPaths(msg) {
        return this.info.btcGetAccountPaths(msg);
    }
    btcIsSameAccount(msg) {
        // TODO: mixed-mode segwit was added in v6.0.2
        // https://github.com/keepkey/keepkey-firmware/pull/81
        // if (firmware_version.lt('6.0.2') && msg.length > 1)
        //  return false
        return this.info.btcIsSameAccount(msg);
    }
    ethSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethSignTx(this.transport, msg);
        });
    }
    ethGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethGetAddress(this.transport, msg);
        });
    }
    ethSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethSignMessage(this.transport, msg);
        });
    }
    ethSignTypedData(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethSignTypedData(this.transport, msg);
        });
    }
    ethVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethVerifyMessage(this.transport, msg);
        });
    }
    ethSupportsNetwork(chain_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.info.ethSupportsNetwork(chain_id);
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.info.ethSupportsSecureTransfer();
        });
    }
    ethSupportsNativeShapeShift() {
        return this.info.ethSupportsNativeShapeShift();
    }
    ethGetAccountPaths(msg) {
        return this.info.ethGetAccountPaths(msg);
    }
    rippleGetAccountPaths(msg) {
        return this.info.rippleGetAccountPaths(msg);
    }
    rippleGetAddress(msg) {
        return Ripple.rippleGetAddress(this.transport, msg);
    }
    rippleSignTx(msg) {
        return Ripple.rippleSignTx(this.transport, msg);
    }
    cosmosGetAccountPaths(msg) {
        return this.info.cosmosGetAccountPaths(msg);
    }
    cosmosGetAddress(msg) {
        return Cosmos.cosmosGetAddress(this.transport, msg);
    }
    cosmosSignTx(msg) {
        return Cosmos.cosmosSignTx(this.transport, msg);
    }
    osmosisGetAccountPaths(msg) {
        return this.info.osmosisGetAccountPaths(msg);
    }
    osmosisGetAddress(msg) {
        return Osmosis.osmosisGetAddress(this.transport, msg);
    }
    osmosisSignTx(msg) {
        return Osmosis.osmosisSignTx(this.transport, msg);
    }
    thorchainGetAccountPaths(msg) {
        return this.info.thorchainGetAccountPaths(msg);
    }
    thorchainGetAddress(msg) {
        return Thorchain.thorchainGetAddress(this.transport, msg);
    }
    thorchainSignTx(msg) {
        return Thorchain.thorchainSignTx(this.transport, msg);
    }
    binanceGetAccountPaths(msg) {
        return this.info.binanceGetAccountPaths(msg);
    }
    binanceGetAddress(msg) {
        return Binance.binanceGetAddress(this.transport, msg);
    }
    binanceSignTx(msg) {
        return Binance.binanceSignTx(this.transport, msg);
    }
    eosGetAccountPaths(msg) {
        return this.info.eosGetAccountPaths(msg);
    }
    eosGetPublicKey(msg) {
        return Eos.eosGetPublicKey(this.transport, msg);
    }
    eosSignTx(msg) {
        return Eos.eosSignTx(this.transport, msg);
    }
    describePath(msg) {
        return this.info.describePath(msg);
    }
    disconnect() {
        return this.transport.disconnect();
    }
    btcNextAccountPath(msg) {
        return this.info.btcNextAccountPath(msg);
    }
    ethNextAccountPath(msg) {
        return this.info.ethNextAccountPath(msg);
    }
    eosNextAccountPath(msg) {
        return this.info.eosNextAccountPath(msg);
    }
    cosmosNextAccountPath(msg) {
        return this.info.cosmosNextAccountPath(msg);
    }
    osmosisNextAccountPath(msg) {
        return this.info.osmosisNextAccountPath(msg);
    }
    rippleNextAccountPath(msg) {
        return this.info.rippleNextAccountPath(msg);
    }
    binanceNextAccountPath(msg) {
        return this.info.binanceNextAccountPath(msg);
    }
}
exports.KeepKeyHDWallet = KeepKeyHDWallet;
function info() {
    return new KeepKeyHDWalletInfo();
}
exports.info = info;
function create(transport) {
    return new KeepKeyHDWallet(transport);
}
exports.create = create;
//# sourceMappingURL=keepkey.js.map