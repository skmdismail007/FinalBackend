"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethVerifyMessage = exports.ethSignTypedData = exports.ethSignMessage = exports.ethGetAddress = exports.ethSignTx = exports.ethGetAccountPaths = exports.ethSupportsNativeShapeShift = exports.ethSupportsSecureTransfer = exports.ethSupportsNetwork = void 0;
const common_1 = __importDefault(require("@ethereumjs/common"));
const tx_1 = require("@ethereumjs/tx");
const Messages = __importStar(require("@keepkey/device-protocol/lib/messages_pb"));
const Ethereum = __importStar(require("@keepkey/device-protocol/lib/messages-ethereum_pb"));
const Types = __importStar(require("@keepkey/device-protocol/lib/types_pb"));
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const eip_712_1 = require("eip-712");
const eip55 = __importStar(require("eip55"));
const ethers = __importStar(require("ethers"));
const utils_1 = require("./utils");
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function ethSupportsNetwork(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        return true;
    });
}
exports.ethSupportsNetwork = ethSupportsNetwork;
function ethSupportsSecureTransfer() {
    return __awaiter(this, void 0, void 0, function* () {
        return true;
    });
}
exports.ethSupportsSecureTransfer = ethSupportsSecureTransfer;
function ethSupportsNativeShapeShift() {
    return true;
}
exports.ethSupportsNativeShapeShift = ethSupportsNativeShapeShift;
function ethGetAccountPaths(msg) {
    const slip44 = core.slip44ByCoin(msg.coin);
    if (slip44 === undefined)
        return [];
    return [
        {
            addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx, 0, 0],
            hardenedPath: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx],
            relPath: [0, 0],
            description: "KeepKey",
        },
    ];
}
exports.ethGetAccountPaths = ethGetAccountPaths;
function stripLeadingZeroes(buf) {
    const firstZeroIndex = buf.findIndex((x) => x !== 0);
    return buf.slice(firstZeroIndex !== -1 ? firstZeroIndex : buf.length);
}
function ethSignTx(transport, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {
            const est = new Ethereum.EthereumSignTx();
            est.setAddressNList(msg.addressNList);
            est.setNonce(stripLeadingZeroes(core.arrayify(msg.nonce)));
            est.setGasLimit(core.arrayify(msg.gasLimit));
            if (msg.gasPrice) {
                est.setGasPrice(core.arrayify(msg.gasPrice));
            }
            if (msg.maxFeePerGas) {
                est.setMaxFeePerGas(core.arrayify(msg.maxFeePerGas));
                est.setType(core.ETHTransactionType.ETH_TX_TYPE_EIP_1559);
                if (msg.maxPriorityFeePerGas) {
                    est.setMaxPriorityFeePerGas(core.arrayify(msg.maxPriorityFeePerGas));
                }
            }
            if (msg.value.match("^0x0*$") === null) {
                est.setValue(core.arrayify(msg.value));
            }
            if (msg.toAddressNList) {
                est.setAddressType(Types.OutputAddressType.SPEND);
                est.setToAddressNList(msg.toAddressNList);
            }
            else {
                est.setAddressType(Types.OutputAddressType.SPEND);
            }
            if (msg.to) {
                est.setTo(core.arrayify(msg.to));
            }
            let dataChunk = null;
            let dataRemaining = undefined;
            if (msg.data) {
                dataRemaining = core.arrayify(msg.data);
                est.setDataLength(dataRemaining.length);
                dataChunk = dataRemaining.slice(0, 1024);
                dataRemaining = dataRemaining.slice(dataChunk.length);
                est.setDataInitialChunk(dataChunk);
            }
            if (msg.chainId !== undefined) {
                est.setChainId(msg.chainId);
            }
            let response;
            let nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTX, est, {
                msgTimeout: core.LONG_TIMEOUT,
                omitLock: true,
            });
            response = nextResponse.proto;
            try {
                const esa = new Ethereum.EthereumTxAck();
                while (response.hasDataLength()) {
                    const dataLength = response.getDataLength();
                    dataRemaining = core.mustBeDefined(dataRemaining);
                    dataChunk = dataRemaining.slice(0, dataLength);
                    dataRemaining = dataRemaining.slice(dataLength, dataRemaining.length);
                    esa.setDataChunk(dataChunk);
                    nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMTXACK, esa, {
                        msgTimeout: core.LONG_TIMEOUT,
                        omitLock: true,
                    });
                    response = nextResponse.proto;
                }
            }
            catch (error) {
                console.error({ error });
                throw new Error("Failed to sign ETH transaction");
            }
            const utxBase = {
                to: msg.to,
                value: msg.value,
                data: msg.data,
                chainId: msg.chainId,
                nonce: msg.nonce,
                gasLimit: msg.gasLimit,
                maxFeePerGas: msg.maxFeePerGas,
                maxPriorityFeePerGas: msg.maxPriorityFeePerGas,
            };
            const r = "0x" + core.toHexString(response.getSignatureR_asU8());
            const s = "0x" + core.toHexString(response.getSignatureS_asU8());
            if (!response.hasSignatureV())
                throw new Error("could not get v");
            const v = core.mustBeDefined(response.getSignatureV());
            const v2 = "0x" + v.toString(16);
            const common = common_1.default.custom({ chainId: msg.chainId });
            const tx = msg.maxFeePerGas
                ? tx_1.FeeMarketEIP1559Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), { maxFeePerGas: msg.maxFeePerGas, maxPriorityFeePerGas: msg.maxPriorityFeePerGas, r: r, s: s, v: v2 }))
                : tx_1.Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), { gasPrice: msg.gasPrice, r: r, s: s, v: v2 }), { common });
            return {
                r,
                s,
                v,
                serialized: "0x" + core.toHexString(tx.serialize()),
            };
        }));
    });
}
exports.ethSignTx = ethSignTx;
function ethGetAddress(transport, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        const getAddr = new Ethereum.EthereumGetAddress();
        getAddr.setAddressNList(msg.addressNList);
        getAddr.setShowDisplay(msg.showDisplay !== false);
        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMGETADDRESS, getAddr, {
            msgTimeout: core.LONG_TIMEOUT,
        });
        const ethAddress = response.proto;
        let address;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (ethAddress.hasAddressStr())
            address = ethAddress.getAddressStr();
        else if (ethAddress.hasAddress())
            address = "0x" + core.toHexString(ethAddress.getAddress_asU8());
        else
            throw new Error("Unable to obtain ETH address from device.");
        return address;
    });
}
exports.ethGetAddress = ethGetAddress;
function ethSignMessage(transport, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        const m = new Ethereum.EthereumSignMessage();
        m.setAddressNList(msg.addressNList);
        m.setMessage(ethers.utils.isBytes(msg.message) ? ethers.utils.arrayify(msg.message) : utils_1.toUTF8Array(msg.message));
        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, m, {
            msgTimeout: core.LONG_TIMEOUT,
        });
        const sig = response.proto;
        return {
            address: eip55.encode("0x" + core.toHexString(sig.getAddress_asU8())),
            signature: "0x" + core.toHexString(sig.getSignature_asU8()),
        };
    });
}
exports.ethSignMessage = ethSignMessage;
function ethSignTypedData(transport, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        /**
         * If the message to be signed is sufficiently small, the KeepKey can calculate the
         * domain separator and message hashes. Otherwise, we need to pre-calculate hashes
         * here and verify on device.
         */
        const sTypes = JSON.stringify({ types: msg.typedData.types });
        const sPrimaryType = JSON.stringify({ primaryType: msg.typedData.primaryType });
        const sDomain = JSON.stringify({ domain: msg.typedData.domain });
        const sMessage = JSON.stringify({ message: msg.typedData.message });
        try {
            if (sTypes.length > 2048 || sPrimaryType.length > 80 || sDomain.length > 2048 || sMessage.length > 2048) {
                /* Pre-calculate domain separator and messages hashes and verify on KeepKey */
                const domainSeparatorHash = eip_712_1.getTypeHash(msg.typedData, "EIP712Domain");
                const domainSeparatorHash64 = Buffer.from(domainSeparatorHash).toString("base64");
                const messageHash = eip_712_1.getMessage(msg.typedData, true);
                const messageHash64 = Buffer.from(messageHash).toString("base64");
                const t = new Ethereum.EthereumSignTypedHash();
                t.setAddressNList(msg.addressNList);
                t.setDomainSeparatorHash(domainSeparatorHash64);
                t.setMessageHash(messageHash64);
                const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTYPEDHASH, t, {
                    msgTimeout: core.LONG_TIMEOUT,
                });
                const result = response.proto;
                const res = {
                    address: result.getAddress() || "",
                    signature: "0x" + core.toHexString(result.getSignature_asU8()),
                };
                return res;
            }
            else {
                /* Let KeepKey calculate domain separator and message hashes */
                const dsh = new Ethereum.Ethereum712TypesValues();
                dsh.setAddressNList(msg.addressNList);
                dsh.setEip712types(sTypes);
                dsh.setEip712primetype(sPrimaryType);
                dsh.setEip712data(sDomain);
                dsh.setEip712typevals(1);
                let response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, dsh, {
                    msgTimeout: core.LONG_TIMEOUT,
                    omitLock: true,
                });
                const mh = new Ethereum.Ethereum712TypesValues();
                mh.setAddressNList(msg.addressNList);
                mh.setEip712types(sTypes);
                mh.setEip712primetype(sPrimaryType);
                mh.setEip712data(sMessage);
                mh.setEip712typevals(2);
                response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, mh, {
                    msgTimeout: core.LONG_TIMEOUT,
                    omitLock: true,
                });
                const result = response.proto;
                const res = {
                    address: result.getAddress() || "",
                    signature: "0x" + core.toHexString(result.getSignature_asU8()),
                };
                return res;
            }
        }
        catch (error) {
            console.error({ error });
            throw new Error("Failed to sign typed ETH message");
        }
    });
}
exports.ethSignTypedData = ethSignTypedData;
function ethVerifyMessage(transport, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        const m = new Ethereum.EthereumVerifyMessage();
        m.setAddress(core.arrayify(msg.address));
        m.setSignature(core.arrayify(msg.signature));
        m.setMessage(ethers.utils.isBytes(msg.message) ? ethers.utils.arrayify(msg.message) : utils_1.toUTF8Array(msg.message));
        let event;
        try {
            event = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMVERIFYMESSAGE, m, {
                msgTimeout: core.LONG_TIMEOUT,
            });
        }
        catch (e) {
            if (core.isIndexable(e) && e.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {
                return false;
            }
            throw e;
        }
        const success = event.proto;
        return success.getMessage() === "Message verified";
    });
}
exports.ethVerifyMessage = ethVerifyMessage;
//# sourceMappingURL=ethereum.js.map