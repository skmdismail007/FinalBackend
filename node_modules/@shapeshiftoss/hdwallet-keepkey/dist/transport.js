"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
const Messages = __importStar(require("@keepkey/device-protocol/lib/messages_pb"));
const Types = __importStar(require("@keepkey/device-protocol/lib/types_pb"));
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const crypto = __importStar(require("crypto"));
const jspb = __importStar(require("google-protobuf"));
const typeRegistry_1 = require("./typeRegistry");
const utils_1 = require("./utils");
class Transport extends core.Transport {
    constructor(keyring, delegate) {
        super(keyring);
        this.debugLink = false;
        this.userActionRequired = false;
        /// One per transport, unlike on Trezor, since the contention is
        /// only per-device, not global.
        this.callInProgress = {
            main: undefined,
            debug: undefined,
        };
        this.delegate = delegate;
    }
    static create(keyring, delegate) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Transport(keyring, delegate);
        });
    }
    isOpened() {
        return this.delegate.isOpened();
    }
    getDeviceID() {
        return this.delegate.getDeviceID();
    }
    connect() {
        return this.delegate.connect();
    }
    tryConnectDebugLink() {
        return __awaiter(this, void 0, void 0, function* () {
            let out = false;
            if (this.delegate.tryConnectDebugLink && (yield this.delegate.tryConnectDebugLink()))
                out = true;
            this.debugLink = out;
            return out;
        });
    }
    disconnect() {
        return this.delegate.disconnect();
    }
    write(buf, debugLink) {
        return __awaiter(this, void 0, void 0, function* () {
            // break frame into segments
            for (let i = 0; i < buf.length; i += utils_1.SEGMENT_SIZE) {
                const segment = buf.slice(i, i + utils_1.SEGMENT_SIZE);
                const padding = new Uint8Array(utils_1.SEGMENT_SIZE - segment.length);
                const fragments = [];
                fragments.push(new Uint8Array([utils_1.SEGMENT_SIZE]));
                fragments.push(segment);
                fragments.push(padding);
                const fragmentBuffer = new Uint8Array(fragments.map((x) => x.length).reduce((a, x) => a + x, 0));
                fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);
                yield this.delegate.writeChunk(fragmentBuffer, debugLink);
            }
        });
    }
    read(debugLink) {
        return __awaiter(this, void 0, void 0, function* () {
            const first = yield this.delegate.readChunk(debugLink);
            // Check that buffer starts with: "?##" [ 0x3f, 0x23, 0x23 ]
            // "?" = USB reportId, "##" = KeepKey magic bytes
            // Message ID is bytes 4-5. Message length starts at byte 6.
            const firstView = new DataView(first.buffer.slice(first.byteOffset, first.byteOffset + first.byteLength));
            const valid = (firstView.getUint32(0) & 0xffffff00) === 0x3f232300;
            const msgLength = firstView.getUint32(5);
            if (!valid)
                throw new Error("message not valid");
            const buffer = new Uint8Array(9 + msgLength);
            buffer.set(first.slice(0, Math.min(first.length, buffer.length)));
            for (let offset = first.length; offset < buffer.length;) {
                // Drop USB "?" reportId in the first byte
                const next = (yield this.delegate.readChunk(debugLink)).slice(1);
                buffer.set(next.slice(0, Math.min(next.length, buffer.length - offset)), offset);
                offset += next.length;
            }
            return buffer;
        });
    }
    getVendor() {
        return "KeepKey";
    }
    getEntropy(length) {
        if (typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.crypto)) {
            return window.crypto.getRandomValues(new Uint8Array(length));
        }
        return crypto.randomBytes(length);
    }
    getFirmwareHash(firmware) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.crypto)) {
                return new Uint8Array(yield window.crypto.subtle.digest({ name: "SHA-256" }, firmware));
            }
            const hash = crypto.createHash("sha256");
            hash.update(firmware);
            return hash.digest();
        });
    }
    /**
     * Utility function to cancel all pending calls whenver one of them is cancelled.
     */
    cancellable(inProgress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield inProgress;
            }
            catch (e) {
                // Throw away the error, as the other context will handle it,
                // unless it was a cancel, in which case we cancel everything.
                if (core.isIndexable(e) && e.type === core.HDWalletErrorType.ActionCancelled) {
                    this.callInProgress = { main: undefined, debug: undefined };
                    throw e;
                }
            }
        });
    }
    lockDuring(action) {
        return __awaiter(this, void 0, void 0, function* () {
            this.callInProgress.main = (() => __awaiter(this, void 0, void 0, function* () {
                yield this.cancellable(this.callInProgress.main);
                return action();
            }))();
            return this.callInProgress.main;
        });
    }
    handleCancellableResponse() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.readResponse(false);
        });
    }
    readResponse(debugLink) {
        return __awaiter(this, void 0, void 0, function* () {
            let buf;
            do {
                buf = yield this.read(debugLink);
            } while (!buf);
            const [msgTypeEnum, msg] = this.fromMessageBuffer(buf);
            const event = core.makeEvent({
                message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],
                message_enum: msgTypeEnum,
                message: msg.toObject(),
                proto: msg,
                from_wallet: true,
            });
            this.emit(String(msgTypeEnum), event);
            if (debugLink)
                return event;
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_FAILURE) {
                const failureEvent = core.makeEvent({
                    message_type: core.Events.FAILURE,
                    message_enum: msgTypeEnum,
                    message: msg.toObject(),
                    from_wallet: true,
                });
                this.emit(core.Events.FAILURE, failureEvent);
                return failureEvent;
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_BUTTONREQUEST) {
                this.emit(core.Events.BUTTON_REQUEST, core.makeEvent({
                    message_type: core.Events.BUTTON_REQUEST,
                    from_wallet: true,
                }));
                this.userActionRequired = true;
                return this.call(Messages.MessageType.MESSAGETYPE_BUTTONACK, new Messages.ButtonAck(), {
                    msgTimeout: core.LONG_TIMEOUT,
                    omitLock: true,
                });
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_ENTROPYREQUEST) {
                const ack = new Messages.EntropyAck();
                ack.setEntropy(this.getEntropy(32));
                return this.call(Messages.MessageType.MESSAGETYPE_ENTROPYACK, ack, {
                    msgTimeout: core.LONG_TIMEOUT,
                    omitLock: true,
                });
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PINMATRIXREQUEST) {
                this.emit(core.Events.PIN_REQUEST, core.makeEvent({
                    message_type: core.Events.PIN_REQUEST,
                    from_wallet: true,
                }));
                this.userActionRequired = true;
                return this.handleCancellableResponse();
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PASSPHRASEREQUEST) {
                this.emit(core.Events.PASSPHRASE_REQUEST, core.makeEvent({
                    message_type: core.Events.PASSPHRASE_REQUEST,
                    from_wallet: true,
                }));
                this.userActionRequired = true;
                return this.handleCancellableResponse();
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_CHARACTERREQUEST) {
                this.emit(core.Events.CHARACTER_REQUEST, core.makeEvent({
                    message_type: core.Events.CHARACTER_REQUEST,
                    from_wallet: true,
                }));
                this.userActionRequired = true;
                return this.handleCancellableResponse();
            }
            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_WORDREQUEST) {
                this.emit(core.Events.WORD_REQUEST, core.makeEvent({
                    message_type: core.Events.WORD_REQUEST,
                    from_wallet: true,
                }));
                this.userActionRequired = true;
                return this.handleCancellableResponse();
            }
            return event;
        });
    }
    call(msgTypeEnum, msg, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            options !== null && options !== void 0 ? options : (options = {});
            (_a = options.msgTimeout) !== null && _a !== void 0 ? _a : (options.msgTimeout = core.DEFAULT_TIMEOUT);
            this.emit(String(msgTypeEnum), core.makeEvent({
                message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],
                message_enum: msgTypeEnum,
                message: msg.toObject(),
                proto: msg,
                from_wallet: false,
            }));
            const makePromise = () => __awaiter(this, void 0, void 0, function* () {
                if ([
                    Messages.MessageType.MESSAGETYPE_BUTTONACK,
                    Messages.MessageType.MESSAGETYPE_PASSPHRASEACK,
                    Messages.MessageType.MESSAGETYPE_CHARACTERACK,
                    Messages.MessageType.MESSAGETYPE_PINMATRIXACK,
                    Messages.MessageType.MESSAGETYPE_WORDACK,
                ].includes(msgTypeEnum)) {
                    this.userActionRequired = true;
                }
                yield this.write(this.toMessageBuffer(msgTypeEnum, msg), !!(options === null || options === void 0 ? void 0 : options.debugLink));
                if (options === null || options === void 0 ? void 0 : options.noWait)
                    return undefined;
                const response = yield this.readResponse(!!(options === null || options === void 0 ? void 0 : options.debugLink));
                this.userActionRequired = false;
                if (response.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE &&
                    response.message.code === Types.FailureType.FAILURE_ACTIONCANCELLED) {
                    this.callInProgress = { main: undefined, debug: undefined };
                    throw new core.ActionCancelled();
                }
                if (response.message_type === core.Events.FAILURE)
                    throw response;
                return response;
            });
            if (options === null || options === void 0 ? void 0 : options.omitLock)
                return makePromise();
            // See the comments in hdwallet-trezor-connect's call for why this weird
            // sequence. We've got a very similar issue here that needs pretty much
            // the same solution.
            const lockKey = (options === null || options === void 0 ? void 0 : options.debugLink) ? "debug" : "main";
            this.callInProgress[lockKey] = (() => __awaiter(this, void 0, void 0, function* () {
                yield this.cancellable(this.callInProgress[lockKey]);
                try {
                    return makePromise();
                }
                finally {
                    this.userActionRequired = false;
                }
            }))();
            return yield this.callInProgress[lockKey];
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.userActionRequired)
                return;
            try {
                this.callInProgress = { main: undefined, debug: undefined };
                const cancelMsg = new Messages.Cancel();
                yield this.call(Messages.MessageType.MESSAGETYPE_CANCEL, cancelMsg, {
                    noWait: this.userActionRequired,
                });
            }
            catch (e) {
                console.error("Cancel Pending Error", e);
            }
            finally {
                this.callInProgress = { main: undefined, debug: undefined };
            }
        });
    }
    toMessageBuffer(msgTypeEnum, msg) {
        const messageBuffer = msg.serializeBinary();
        const headerBuffer = new Uint8Array(8);
        const headerView = new DataView(headerBuffer.buffer);
        headerView.setUint8(0, 0x23);
        headerView.setUint8(1, 0x23);
        headerView.setUint16(2, msgTypeEnum);
        headerView.setUint32(4, messageBuffer.byteLength);
        const fragments = [headerBuffer, messageBuffer];
        const fragmentBuffer = new Uint8Array(fragments.map((x) => x.length).reduce((a, x) => a + x, 0));
        fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);
        return fragmentBuffer;
    }
    fromMessageBuffer(buf) {
        const typeID = new DataView(buf.buffer).getUint16(3);
        const MType = typeRegistry_1.messageTypeRegistry[typeID];
        if (!MType) {
            const msg = new Messages.Failure();
            msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);
            msg.setMessage("Unknown message type received");
            return [Messages.MessageType.MESSAGETYPE_FAILURE, msg];
        }
        const msg = new MType();
        const reader = new jspb.BinaryReader(buf, 9, buf.length - 9);
        return [typeID, MType.deserializeBinaryFromReader(msg, reader)];
    }
    static failureMessageFactory(e) {
        const msg = new Messages.Failure();
        msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);
        if (typeof e === "string") {
            msg.setMessage(e);
        }
        else {
            msg.setMessage(String(e));
        }
        return msg.serializeBinary();
    }
}
exports.Transport = Transport;
//# sourceMappingURL=transport.js.map